(function()
{
    function a(b, c)
    {
        (null === b || void 0 === b) && a.warn("Warning", "You must pass your app key when you instantiate Pusher."), c = c ||
        {};
        var d = this;
        this.key = b, this.config = a.Util.extend(a.getGlobalConfig(), c.cluster ? a.getClusterConfig(c.cluster) :
        {}, c), this.channels = new a.Channels, this.global_emitter = new a.EventsDispatcher, this.sessionID = Math.floor(1e9 * Math.random()), this.timeline = new a.Timeline(this.key, this.sessionID,
        {
            cluster: this.config.cluster,
            features: a.Util.getClientFeatures(),
            params: this.config.timelineParams ||
            {},
            limit: 50,
            level: a.Timeline.INFO,
            version: a.VERSION
        }), this.connection = new a.ConnectionManager(this.key, a.Util.extend(
        {
            getStrategy: function(b)
            {
                return b = a.Util.extend(
                {}, d.config, b), a.StrategyBuilder.build(a.getDefaultStrategy(b), b)
            },
            timeline: this.timeline,
            activityTimeout: this.config.activity_timeout,
            pongTimeout: this.config.pong_timeout,
            unavailableTimeout: this.config.unavailable_timeout
        }, this.config,
        {
            encrypted: this.isEncrypted()
        })), this.connection.bind("connected", function()
        {
            d.subscribeAll(), d.timelineSender && d.timelineSender.send(d.connection.isEncrypted())
        }), this.connection.bind("message", function(a)
        {
            var b = 0 === a.event.indexOf("pusher_internal:");
            if (a.channel)
            {
                var c = d.channel(a.channel);
                c && c.handleEvent(a.event, a.data)
            }
            b || d.global_emitter.emit(a.event, a.data)
        }), this.connection.bind("disconnected", function()
        {
            d.channels.disconnect()
        }), this.connection.bind("error", function(b)
        {
            a.warn("Error", b)
        }), a.instances.push(this), this.timeline.info(
        {
            instances: a.instances.length
        }), a.isReady && d.connect()
    }
    var b = a.prototype;
    a.instances = [], a.isReady = !1, a.debug = function()
    {
        a.log && a.log(a.Util.stringify.apply(this, arguments))
    }, a.warn = function()
    {
        var b = a.Util.stringify.apply(this, arguments);
        window.console && (window.console.warn ? window.console.warn(b) : window.console.log && window.console.log(b)), a.log && a.log(b)
    }, a.ready = function()
    {
        a.isReady = !0;
        for (var b = 0, c = a.instances.length; c > b; b++) a.instances[b].connect()
    }, b.channel = function(a)
    {
        return this.channels.find(a)
    }, b.allChannels = function()
    {
        return this.channels.all()
    }, b.connect = function()
    {
        if (this.connection.connect(), this.timelineSender && !this.timelineSenderTimer)
        {
            var b = this.connection.isEncrypted(),
                c = this.timelineSender;
            this.timelineSenderTimer = new a.PeriodicTimer(6e4, function()
            {
                c.send(b)
            })
        }
    }, b.disconnect = function()
    {
        this.connection.disconnect(), this.timelineSenderTimer && (this.timelineSenderTimer.ensureAborted(), this.timelineSenderTimer = null)
    }, b.bind = function(a, b)
    {
        return this.global_emitter.bind(a, b), this
    }, b.bind_all = function(a)
    {
        return this.global_emitter.bind_all(a), this
    }, b.subscribeAll = function()
    {
        for (var a in this.channels.channels) this.channels.channels.hasOwnProperty(a) && this.subscribe(a)
    }, b.subscribe = function(a)
    {
        return a = this.channels.add(a, this), "connected" === this.connection.state && a.subscribe(), a
    }, b.unsubscribe = function(a)
    {
        a = this.channels.remove(a), "connected" === this.connection.state && a.unsubscribe()
    }, b.send_event = function(a, b, c)
    {
        return this.connection.send_event(a, b, c)
    }, b.isEncrypted = function()
    {
        return "https:" === a.Util.getDocument().location.protocol ? !0 : Boolean(this.config.encrypted)
    }, a.HTTP = {}, this.Pusher = a
}).call(this),
    function()
    {
        function a(a)
        {
            window.clearTimeout(a)
        }

        function b(a)
        {
            window.clearInterval(a)
        }

        function c(a, b, c, d)
        {
            var e = this;
            this.clear = b, this.timer = a(function()
            {
                null !== e.timer && (e.timer = d(e.timer))
            }, c)
        }
        var d = c.prototype;
        d.isRunning = function()
        {
            return null !== this.timer
        }, d.ensureAborted = function()
        {
            this.timer && (this.clear(this.timer), this.timer = null)
        }, Pusher.Timer = function(b, d)
        {
            return new c(setTimeout, a, b, function(a)
            {
                return d(), null
            })
        }, Pusher.PeriodicTimer = function(a, d)
        {
            return new c(setInterval, b, a, function(a)
            {
                return d(), a
            })
        }
    }.call(this),
    function()
    {
        Pusher.Util = {
            now: function()
            {
                return Date.now ? Date.now() : (new Date).valueOf()
            },
            defer: function(a)
            {
                return new Pusher.Timer(0, a)
            },
            extend: function(a)
            {
                for (var b = 1; b < arguments.length; b++)
                {
                    var d, c = arguments[b];
                    for (d in c) a[d] = c[d] && c[d].constructor && c[d].constructor === Object ? Pusher.Util.extend(a[d] ||
                    {}, c[d]) : c[d]
                }
                return a
            },
            stringify: function()
            {
                for (var a = ["Pusher"], b = 0; b < arguments.length; b++) "string" == typeof arguments[b] ? a.push(arguments[b]) : void 0 === window.JSON ? a.push(arguments[b].toString()) : a.push(JSON.stringify(arguments[b]));
                return a.join(" : ")
            },
            arrayIndexOf: function(a, b)
            {
                var c = Array.prototype.indexOf;
                if (null === a) return -1;
                if (c && a.indexOf === c) return a.indexOf(b);
                for (var c = 0, d = a.length; d > c; c++)
                    if (a[c] === b) return c;
                return -1
            },
            objectApply: function(a, b)
            {
                for (var c in a) Object.prototype.hasOwnProperty.call(a, c) && b(a[c], c, a)
            },
            keys: function(a)
            {
                var b = [];
                return Pusher.Util.objectApply(a, function(a, c)
                {
                    b.push(c)
                }), b
            },
            values: function(a)
            {
                var b = [];
                return Pusher.Util.objectApply(a, function(a)
                {
                    b.push(a)
                }), b
            },
            apply: function(a, b, c)
            {
                for (var d = 0; d < a.length; d++) b.call(c || window, a[d], d, a)
            },
            map: function(a, b)
            {
                for (var c = [], d = 0; d < a.length; d++) c.push(b(a[d], d, a, c));
                return c
            },
            mapObject: function(a, b)
            {
                var c = {};
                return Pusher.Util.objectApply(a, function(a, d)
                {
                    c[d] = b(a)
                }), c
            },
            filter: function(a, b)
            {
                b = b || function(a)
                {
                    return !!a
                };
                for (var c = [], d = 0; d < a.length; d++) b(a[d], d, a, c) && c.push(a[d]);
                return c
            },
            filterObject: function(a, b)
            {
                var c = {};
                return Pusher.Util.objectApply(a, function(d, e)
                {
                    (b && b(d, e, a, c) || Boolean(d)) && (c[e] = d)
                }), c
            },
            flatten: function(a)
            {
                var b = [];
                return Pusher.Util.objectApply(a, function(a, c)
                {
                    b.push([c, a])
                }), b
            },
            any: function(a, b)
            {
                for (var c = 0; c < a.length; c++)
                    if (b(a[c], c, a)) return !0;
                return !1
            },
            all: function(a, b)
            {
                for (var c = 0; c < a.length; c++)
                    if (!b(a[c], c, a)) return !1;
                return !0
            },
            method: function(a)
            {
                var b = Array.prototype.slice.call(arguments, 1);
                return function(c)
                {
                    return c[a].apply(c, b.concat(arguments))
                }
            },
            getWindow: function()
            {
                return window
            },
            getDocument: function()
            {
                return document
            },
            getNavigator: function()
            {
                return navigator
            },
            getLocalStorage: function()
            {
                try
                {
                    return window.localStorage
                }
                catch (a)
                {}
            },
            getClientFeatures: function()
            {
                return Pusher.Util.keys(Pusher.Util.filterObject(
                {
                    ws: Pusher.WSTransport,
                    flash: Pusher.FlashTransport
                }, function(a)
                {
                    return a.isSupported(
                    {})
                }))
            },
            addWindowListener: function(a, b)
            {
                var c = Pusher.Util.getWindow();
                void 0 !== c.addEventListener ? c.addEventListener(a, b, !1) : c.attachEvent("on" + a, b)
            },
            removeWindowListener: function(a, b)
            {
                var c = Pusher.Util.getWindow();
                void 0 !== c.addEventListener ? c.removeEventListener(a, b, !1) : c.detachEvent("on" + a, b)
            },
            isXHRSupported: function()
            {
                var a = window.XMLHttpRequest;
                return Boolean(a) && void 0 !== (new a).withCredentials
            },
            isXDRSupported: function(a)
            {
                a = a ? "https:" : "http:";
                var b = Pusher.Util.getDocument().location.protocol;
                return Boolean(window.XDomainRequest) && b === a
            }
        }
    }.call(this),
    function()
    {
        var a = window.location.origin,
            b = window.location.host;
        Pusher.VERSION = "2.2.4", Pusher.PROTOCOL = 7, Pusher.host = b, Pusher.ws_port = 8080, Pusher.wss_port = 8080, Pusher.sockjs_host = b, Pusher.sockjs_http_port = 8080, Pusher.sockjs_https_port = 8080, Pusher.sockjs_path = "/pusher", Pusher.stats_host = b, Pusher.channel_auth_endpoint = "/pusher/auth", Pusher.channel_auth_transport = "ajax", Pusher.activity_timeout = 12e4, Pusher.pong_timeout = 3e4, Pusher.unavailable_timeout = 1e4, Pusher.cdn_http = a, Pusher.cdn_https = b, Pusher.dependency_suffix = ".min", Pusher.getDefaultStrategy = function(a)
        {
            return [
                [":def", "ws_options",
                {
                    hostUnencrypted: a.wsHost + ":" + a.wsPort,
                    hostEncrypted: a.wsHost + ":" + a.wssPort
                }],
                [":def", "wss_options", [":extend", ":ws_options",
                {
                    encrypted: !0
                }]],
                [":def", "sockjs_options",
                {
                    hostUnencrypted: a.httpHost + ":" + a.httpPort,
                    hostEncrypted: a.httpHost + ":" + a.httpsPort,
                    httpPath: a.httpPath
                }],
                [":def", "timeouts",
                {
                    loop: !0,
                    timeout: 15e3,
                    timeoutLimit: 6e4
                }],
                [":def", "ws_manager", [":transport_manager",
                {
                    lives: 2,
                    minPingDelay: 1e4,
                    maxPingDelay: a.activity_timeout
                }]],
                [":def", "streaming_manager", [":transport_manager",
                {
                    lives: 2,
                    minPingDelay: 1e4,
                    maxPingDelay: a.activity_timeout
                }]],
                [":def_transport", "ws", "ws", 3, ":ws_options", ":ws_manager"],
                [":def_transport", "wss", "ws", 3, ":wss_options", ":ws_manager"],
                [":def_transport", "flash", "flash", 2, ":ws_options", ":ws_manager"],
                [":def_transport", "sockjs", "sockjs", 1, ":sockjs_options"],
                [":def_transport", "xhr_streaming", "xhr_streaming", 1, ":sockjs_options", ":streaming_manager"],
                [":def_transport", "xdr_streaming", "xdr_streaming", 1, ":sockjs_options", ":streaming_manager"],
                [":def_transport", "xhr_polling", "xhr_polling", 1, ":sockjs_options"],
                [":def_transport", "xdr_polling", "xdr_polling", 1, ":sockjs_options"],
                [":def", "ws_loop", [":sequential", ":timeouts", ":ws"]],
                [":def", "wss_loop", [":sequential", ":timeouts", ":wss"]],
                [":def", "flash_loop", [":sequential", ":timeouts", ":flash"]],
                [":def", "sockjs_loop", [":sequential", ":timeouts", ":sockjs"]],
                [":def", "streaming_loop", [":sequential", ":timeouts", [":if", [":is_supported", ":xhr_streaming"], ":xhr_streaming", ":xdr_streaming"]]],
                [":def", "polling_loop", [":sequential", ":timeouts", [":if", [":is_supported", ":xhr_polling"], ":xhr_polling", ":xdr_polling"]]],
                [":def", "http_loop", [":if", [":is_supported", ":streaming_loop"],
                    [":best_connected_ever", ":streaming_loop", [":delayed", 4e3, [":polling_loop"]]],
                    [":polling_loop"]
                ]],
                [":def", "http_fallback_loop", [":if", [":is_supported", ":http_loop"],
                    [":http_loop"],
                    [":sockjs_loop"]
                ]],
                [":def", "strategy", [":cached", 18e5, [":first_connected", [":if", [":is_supported", ":ws"], a.encrypted ? [":best_connected_ever", ":ws_loop", [":delayed", 2e3, [":http_fallback_loop"]]] : [":best_connected_ever", ":ws_loop", [":delayed", 2e3, [":wss_loop"]],
                        [":delayed", 5e3, [":http_fallback_loop"]]
                    ],
                    [":if", [":is_supported", ":flash"],
                        [":best_connected_ever", ":flash_loop", [":delayed", 2e3, [":http_fallback_loop"]]],
                        [":http_fallback_loop"]
                    ]
                ]]]]
            ]
        }
    }.call(this),
    function()
    {
        Pusher.getGlobalConfig = function()
        {
            return {
                wsHost: Pusher.host,
                wsPort: Pusher.ws_port,
                wssPort: Pusher.wss_port,
                httpHost: Pusher.sockjs_host,
                httpPort: Pusher.sockjs_http_port,
                httpsPort: Pusher.sockjs_https_port,
                httpPath: Pusher.sockjs_path,
                statsHost: Pusher.stats_host,
                authEndpoint: Pusher.channel_auth_endpoint,
                authTransport: Pusher.channel_auth_transport,
                activity_timeout: Pusher.activity_timeout,
                pong_timeout: Pusher.pong_timeout,
                unavailable_timeout: Pusher.unavailable_timeout
            }
        }, Pusher.getClusterConfig = function(a)
        {
            return {
                wsHost: "ws-" + a + ".pusher.com",
                httpHost: "sockjs-" + a + ".pusher.com"
            }
        }
    }.call(this),
    function()
    {
        function a(a)
        {
            var b = function(b)
            {
                Error.call(this, b), this.name = a
            };
            return Pusher.Util.extend(b.prototype, Error.prototype), b
        }
        Pusher.Errors = {
            BadEventName: a("BadEventName"),
            RequestTimedOut: a("RequestTimedOut"),
            TransportPriorityTooLow: a("TransportPriorityTooLow"),
            TransportClosed: a("TransportClosed"),
            UnsupportedTransport: a("UnsupportedTransport"),
            UnsupportedStrategy: a("UnsupportedStrategy")
        }
    }.call(this),
    function()
    {
        function a(a)
        {
            this.callbacks = new b, this.global_callbacks = [], this.failThrough = a
        }

        function b()
        {
            this._callbacks = {}
        }
        var c = a.prototype;
        c.bind = function(a, b, c)
        {
            return this.callbacks.add(a, b, c), this
        }, c.bind_all = function(a)
        {
            return this.global_callbacks.push(a), this
        }, c.unbind = function(a, b, c)
        {
            return this.callbacks.remove(a, b, c), this
        }, c.unbind_all = function(a, b)
        {
            return this.callbacks.remove(a, b), this
        }, c.emit = function(a, b)
        {
            var c;
            for (c = 0; c < this.global_callbacks.length; c++) this.global_callbacks[c](a, b);
            var d = this.callbacks.get(a);
            if (d && 0 < d.length)
                for (c = 0; c < d.length; c++) d[c].fn.call(d[c].context || window, b);
            else this.failThrough && this.failThrough(a, b);
            return this
        }, b.prototype.get = function(a)
        {
            return this._callbacks["_" + a]
        }, b.prototype.add = function(a, b, c)
        {
            a = "_" + a, this._callbacks[a] = this._callbacks[a] || [], this._callbacks[a].push(
            {
                fn: b,
                context: c
            })
        }, b.prototype.remove = function(a, b, c)
        {
            a || b || c ? (a = a ? ["_" + a] : Pusher.Util.keys(this._callbacks), b || c ? Pusher.Util.apply(a, function(a)
            {
                this._callbacks[a] = Pusher.Util.filter(this._callbacks[a] || [], function(a)
                {
                    return b && b !== a.fn || c && c !== a.context
                }), 0 === this._callbacks[a].length && delete this._callbacks[a]
            }, this) : Pusher.Util.apply(a, function(a)
            {
                delete this._callbacks[a]
            }, this)) : this._callbacks = {}
        }, Pusher.EventsDispatcher = a
    }.call(this),
    function()
    {
        function a(a, b)
        {
            this.lastId = 0, this.prefix = a, this.name = b
        }
        var b = a.prototype;
        b.create = function(a)
        {
            this.lastId++;
            var b = this.lastId,
                c = this.prefix + b,
                d = this.name + "[" + b + "]",
                e = !1,
                f = function()
                {
                    e || (a.apply(null, arguments), e = !0)
                };
            return this[b] = f,
            {
                number: b,
                id: c,
                name: d,
                callback: f
            }
        }, b.remove = function(a)
        {
            delete this[a.number]
        }, Pusher.ScriptReceiverFactory = a, Pusher.ScriptReceivers = new a("_pusher_script_", "Pusher.ScriptReceivers")
    }.call(this),
    function()
    {
        function a(a)
        {
            this.src = a
        }
        var b = a.prototype;
        b.send = function(a)
        {
            var b = this,
                c = "Error loading " + b.src;
            b.script = document.createElement("script"), b.script.id = a.id, b.script.src = b.src, b.script.type = "text/javascript", b.script.charset = "UTF-8", b.script.addEventListener ? (b.script.onerror = function()
            {
                a.callback(c)
            }, b.script.onload = function()
            {
                a.callback(null)
            }) : b.script.onreadystatechange = function()
            {
                ("loaded" === b.script.readyState || "complete" === b.script.readyState) && a.callback(null)
            }, void 0 === b.script.async && document.attachEvent && /opera/i.test(navigator.userAgent) ? (b.errorScript = document.createElement("script"), b.errorScript.id = a.id + "_error", b.errorScript.text = a.name + "('" + c + "');", b.script.async = b.errorScript.async = !1) : b.script.async = !0;
            var d = document.getElementsByTagName("head")[0];
            d.insertBefore(b.script, d.firstChild), b.errorScript && d.insertBefore(b.errorScript, b.script.nextSibling)
        }, b.cleanup = function()
        {
            this.script && (this.script.onload = this.script.onerror = null, this.script.onreadystatechange = null), this.script && this.script.parentNode && this.script.parentNode.removeChild(this.script), this.errorScript && this.errorScript.parentNode && this.errorScript.parentNode.removeChild(this.errorScript), this.errorScript = this.script = null
        }, Pusher.ScriptRequest = a
    }.call(this),
    function()
    {
        function a(a)
        {
            this.options = a, this.receivers = a.receivers || Pusher.ScriptReceivers, this.loading = {}
        }
        var b = a.prototype;
        b.load = function(a, b, c)
        {
            var d = this;
            if (d.loading[a] && 0 < d.loading[a].length) d.loading[a].push(c);
            else
            {
                d.loading[a] = [c];
                var e = new Pusher.ScriptRequest(d.getPath(a, b)),
                    f = d.receivers.create(function(b)
                    {
                        if (d.receivers.remove(f), d.loading[a])
                        {
                            var c = d.loading[a];
                            delete d.loading[a];
                            for (var g = function(a)
                                {
                                    a || e.cleanup()
                                }, h = 0; h < c.length; h++) c[h](b, g)
                        }
                    });
                e.send(f)
            }
        }, b.getRoot = function(a)
        {
            var b = Pusher.Util.getDocument().location.protocol;
            return (a && a.encrypted || "https:" === b ? this.options.cdn_https : this.options.cdn_http).replace(/\/*$/, "") + "/" + this.options.version
        }, b.getPath = function(a, b)
        {
            return this.getRoot(b) + "/" + a + this.options.suffix + ".js"
        }, Pusher.DependencyLoader = a
    }.call(this),
    function()
    {
        function a()
        {
            Pusher.ready()
        }

        function b(a)
        {
            document.body ? a() : setTimeout(function()
            {
                b(a)
            }, 0)
        }

        function c()
        {
            b(a)
        }
        Pusher.DependenciesReceivers = new Pusher.ScriptReceiverFactory("_pusher_dependencies", "Pusher.DependenciesReceivers"), Pusher.Dependencies = new Pusher.DependencyLoader(
        {
            cdn_http: Pusher.cdn_http,
            cdn_https: Pusher.cdn_https,
            version: Pusher.VERSION,
            suffix: Pusher.dependency_suffix,
            receivers: Pusher.DependenciesReceivers
        }), window.JSON ? c() : Pusher.Dependencies.load("json2",
        {}, c)
    }(),
    function()
    {
        for (var a = String.fromCharCode, b = 0; 64 > b; b++) "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(b);
        var c = function(b)
            {
                var c = b.charCodeAt(0);
                return 128 > c ? b : 2048 > c ? a(192 | c >>> 6) + a(128 | 63 & c) : a(224 | c >>> 12 & 15) + a(128 | c >>> 6 & 63) + a(128 | 63 & c)
            },
            d = function(a)
            {
                var b = [0, 2, 1][a.length % 3];
                return a = a.charCodeAt(0) << 16 | (1 < a.length ? a.charCodeAt(1) : 0) << 8 | (2 < a.length ? a.charCodeAt(2) : 0), ["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(a >>> 18), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(a >>> 12 & 63), b >= 2 ? "=" : "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(a >>> 6 & 63), b >= 1 ? "=" : "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(63 & a)].join("")
            },
            e = window.btoa || function(a)
            {
                return a.replace(/[\s\S]{1,3}/g, d)
            };
        Pusher.Base64 = {
            encode: function(a)
            {
                return e(a.replace(/[^\x00-\x7F]/g, c))
            }
        }
    }.call(this),
    function()
    {
        function a(a, b)
        {
            this.url = a, this.data = b
        }

        function b(a)
        {
            return Pusher.Util.mapObject(a, function(a)
            {
                return "object" == typeof a && (a = JSON.stringify(a)), encodeURIComponent(Pusher.Base64.encode(a.toString()))
            })
        }
        var c = a.prototype;
        c.send = function(a)
        {
            if (!this.request)
            {
                var c = Pusher.Util.filterObject(this.data, function(a)
                    {
                        return void 0 !== a
                    }),
                    c = Pusher.Util.map(Pusher.Util.flatten(b(c)), Pusher.Util.method("join", "=")).join("&");
                this.request = new Pusher.ScriptRequest(this.url + "/" + a.number + "?" + c), this.request.send(a)
            }
        }, c.cleanup = function()
        {
            this.request && this.request.cleanup()
        }, Pusher.JSONPRequest = a
    }.call(this),
    function()
    {
        function a(a, b, c)
        {
            this.key = a, this.session = b, this.events = [], this.options = c ||
            {}, this.uniqueID = this.sent = 0
        }
        var b = a.prototype;
        a.ERROR = 3, a.INFO = 6, a.DEBUG = 7, b.log = function(a, b)
        {
            a <= this.options.level && (this.events.push(Pusher.Util.extend(
            {}, b,
            {
                timestamp: Pusher.Util.now()
            })), this.options.limit && this.events.length > this.options.limit && this.events.shift())
        }, b.error = function(b)
        {
            this.log(a.ERROR, b)
        }, b.info = function(b)
        {
            this.log(a.INFO, b)
        }, b.debug = function(b)
        {
            this.log(a.DEBUG, b)
        }, b.isEmpty = function()
        {
            return 0 === this.events.length
        }, b.send = function(a, b)
        {
            var c = this,
                d = Pusher.Util.extend(
                {
                    session: c.session,
                    bundle: c.sent + 1,
                    key: c.key,
                    lib: "js",
                    version: c.options.version,
                    cluster: c.options.cluster,
                    features: c.options.features,
                    timeline: c.events
                }, c.options.params);
            return c.events = [], a(d, function(a, d)
            {
                a || c.sent++, b && b(a, d)
            }), !0
        }, b.generateUniqueID = function()
        {
            return this.uniqueID++, this.uniqueID
        }, Pusher.Timeline = a
    }.call(this),
    function()
    {
        function a(a, b)
        {
            this.timeline = a, this.options = b ||
            {}
        }
        a.prototype.send = function(a, b)
        {
            var c = this;
            c.timeline.isEmpty() || c.timeline.send(function(b, d)
            {
                var e = new Pusher.JSONPRequest("http" + (a ? "s" : "") + "://" + (c.host || c.options.host) + c.options.path, b),
                    f = Pusher.ScriptReceivers.create(function(a, b)
                    {
                        Pusher.ScriptReceivers.remove(f), e.cleanup(), b && b.host && (c.host = b.host), d && d(a, b)
                    });
                e.send(f)
            }, b)
        }, Pusher.TimelineSender = a
    }.call(this),
    function()
    {
        function a(a)
        {
            this.strategies = a
        }

        function b(a, b, c)
        {
            var e = Pusher.Util.map(a, function(a, d, e, f)
            {
                return a.connect(b, c(d, f))
            });
            return {
                abort: function()
                {
                    Pusher.Util.apply(e, d)
                },
                forceMinPriority: function(a)
                {
                    Pusher.Util.apply(e, function(b)
                    {
                        b.forceMinPriority(a)
                    })
                }
            }
        }

        function c(a)
        {
            return Pusher.Util.all(a, function(a)
            {
                return Boolean(a.error)
            })
        }

        function d(a)
        {
            !a.error && !a.aborted && (a.abort(), a.aborted = !0)
        }
        var e = a.prototype;
        e.isSupported = function()
        {
            return Pusher.Util.any(this.strategies, Pusher.Util.method("isSupported"))
        }, e.connect = function(a, d)
        {
            return b(this.strategies, a, function(a, b)
            {
                return function(e, f)
                {
                    (b[a].error = e) ? c(b) && d(!0): (Pusher.Util.apply(b, function(a)
                    {
                        a.forceMinPriority(f.transport.priority)
                    }), d(null, f))
                }
            })
        }, Pusher.BestConnectedEverStrategy = a
    }.call(this),
    function()
    {
        function a(a, b, c)
        {
            this.strategy = a, this.transports = b, this.ttl = c.ttl || 18e5, this.encrypted = c.encrypted, this.timeline = c.timeline
        }

        function b(a)
        {
            return "pusherTransport" + (a ? "Encrypted" : "Unencrypted")
        }

        function c(a)
        {
            var c = Pusher.Util.getLocalStorage();
            if (c) try
            {
                var e = c[b(a)];
                if (e) return JSON.parse(e)
            }
            catch (f)
            {
                d(a)
            }
            return null
        }

        function d(a)
        {
            var c = Pusher.Util.getLocalStorage();
            if (c) try
            {
                delete c[b(a)]
            }
            catch (d)
            {}
        }
        var e = a.prototype;
        e.isSupported = function()
        {
            return this.strategy.isSupported()
        }, e.connect = function(a, e)
        {
            var f = this.encrypted,
                g = c(f),
                h = [this.strategy];
            if (g && g.timestamp + this.ttl >= Pusher.Util.now())
            {
                var i = this.transports[g.transport];
                i && (this.timeline.info(
                {
                    cached: !0,
                    transport: g.transport,
                    latency: g.latency
                }), h.push(new Pusher.SequentialStrategy([i],
                {
                    timeout: 2 * g.latency + 1e3,
                    failFast: !0
                })))
            }
            var j = Pusher.Util.now(),
                k = h.pop().connect(a, function l(c, g)
                {
                    if (c) d(f), 0 < h.length ? (j = Pusher.Util.now(), k = h.pop().connect(a, l)) : e(c);
                    else
                    {
                        var i = g.transport.name,
                            m = Pusher.Util.now() - j,
                            n = Pusher.Util.getLocalStorage();
                        if (n) try
                        {
                            n[b(f)] = JSON.stringify(
                            {
                                timestamp: Pusher.Util.now(),
                                transport: i,
                                latency: m
                            })
                        }
                        catch (o)
                        {}
                        e(null, g)
                    }
                });
            return {
                abort: function()
                {
                    k.abort()
                },
                forceMinPriority: function(b)
                {
                    a = b, k && k.forceMinPriority(b)
                }
            }
        }, Pusher.CachedStrategy = a
    }.call(this),
    function()
    {
        function a(a, b)
        {
            this.strategy = a, this.options = {
                delay: b.delay
            }
        }
        var b = a.prototype;
        b.isSupported = function()
        {
            return this.strategy.isSupported()
        }, b.connect = function(a, b)
        {
            var d, c = this.strategy,
                e = new Pusher.Timer(this.options.delay, function()
                {
                    d = c.connect(a, b)
                });
            return {
                abort: function()
                {
                    e.ensureAborted(), d && d.abort()
                },
                forceMinPriority: function(b)
                {
                    a = b, d && d.forceMinPriority(b)
                }
            }
        }, Pusher.DelayedStrategy = a
    }.call(this),
    function()
    {
        function a(a)
        {
            this.strategy = a
        }
        var b = a.prototype;
        b.isSupported = function()
        {
            return this.strategy.isSupported()
        }, b.connect = function(a, b)
        {
            var c = this.strategy.connect(a, function(a, d)
            {
                d && c.abort(), b(a, d)
            });
            return c
        }, Pusher.FirstConnectedStrategy = a
    }.call(this),
    function()
    {
        function a(a, b, c)
        {
            this.test = a, this.trueBranch = b, this.falseBranch = c
        }
        var b = a.prototype;
        b.isSupported = function()
        {
            return (this.test() ? this.trueBranch : this.falseBranch).isSupported()
        }, b.connect = function(a, b)
        {
            return (this.test() ? this.trueBranch : this.falseBranch).connect(a, b)
        }, Pusher.IfStrategy = a
    }.call(this),
    function()
    {
        function a(a, b)
        {
            this.strategies = a, this.loop = Boolean(b.loop), this.failFast = Boolean(b.failFast), this.timeout = b.timeout, this.timeoutLimit = b.timeoutLimit
        }
        var b = a.prototype;
        b.isSupported = function()
        {
            return Pusher.Util.any(this.strategies, Pusher.Util.method("isSupported"))
        }, b.connect = function(a, b)
        {
            var c = this,
                d = this.strategies,
                e = 0,
                f = this.timeout,
                g = null,
                h = function(i, j)
                {
                    j ? b(null, j) : (e += 1, c.loop && (e %= d.length), e < d.length ? (f && (f *= 2, c.timeoutLimit && (f = Math.min(f, c.timeoutLimit))), g = c.tryStrategy(d[e], a,
                    {
                        timeout: f,
                        failFast: c.failFast
                    }, h)) : b(!0))
                },
                g = this.tryStrategy(d[e], a,
                {
                    timeout: f,
                    failFast: this.failFast
                }, h);
            return {
                abort: function()
                {
                    g.abort()
                },
                forceMinPriority: function(b)
                {
                    a = b, g && g.forceMinPriority(b)
                }
            }
        }, b.tryStrategy = function(a, b, c, d)
        {
            var e = null,
                f = null;
            return 0 < c.timeout && (e = new Pusher.Timer(c.timeout, function()
            {
                f.abort(), d(!0)
            })), f = a.connect(b, function(a, b)
            {
                a && e && e.isRunning() && !c.failFast || (e && e.ensureAborted(), d(a, b))
            }),
            {
                abort: function()
                {
                    e && e.ensureAborted(), f.abort()
                },
                forceMinPriority: function(a)
                {
                    f.forceMinPriority(a)
                }
            }
        }, Pusher.SequentialStrategy = a
    }.call(this),
    function()
    {
        function a(a, b, c, d)
        {
            this.name = a, this.priority = b, this.transport = c, this.options = d ||
            {}
        }

        function b(a, b)
        {
            return Pusher.Util.defer(function()
            {
                b(a)
            }),
            {
                abort: function() {},
                forceMinPriority: function() {}
            }
        }
        var c = a.prototype;
        c.isSupported = function()
        {
            return this.transport.isSupported(
            {
                encrypted: this.options.encrypted
            })
        }, c.connect = function(a, c)
        {
            if (!this.isSupported()) return b(new Pusher.Errors.UnsupportedStrategy, c);
            if (this.priority < a) return b(new Pusher.Errors.TransportPriorityTooLow, c);
            var d = this,
                e = !1,
                f = this.transport.createConnection(this.name, this.priority, this.options.key, this.options),
                g = null,
                h = function()
                {
                    f.unbind("initialized", h), f.connect()
                },
                i = function()
                {
                    g = new Pusher.Handshake(f, function(a)
                    {
                        e = !0, l(), c(null, a)
                    })
                },
                j = function(a)
                {
                    l(), c(a)
                },
                k = function()
                {
                    l(), c(new Pusher.Errors.TransportClosed(f))
                },
                l = function()
                {
                    f.unbind("initialized", h), f.unbind("open", i), f.unbind("error", j), f.unbind("closed", k)
                };
            return f.bind("initialized", h), f.bind("open", i), f.bind("error", j), f.bind("closed", k), f.initialize(),
            {
                abort: function()
                {
                    e || (l(), g ? g.close() : f.close())
                },
                forceMinPriority: function(a)
                {
                    e || d.priority < a && (g ? g.close() : f.close())
                }
            }
        }, Pusher.TransportStrategy = a
    }.call(this),
    function()
    {
        function a(a, b, c)
        {
            return a + (b.encrypted ? "s" : "") + "://" + (b.encrypted ? b.hostEncrypted : b.hostUnencrypted) + c
        }

        function b(a, b)
        {
            return "/app/" + a + ("?protocol=" + Pusher.PROTOCOL + "&client=js&version=" + Pusher.VERSION + (b ? "&" + b : ""))
        }
        Pusher.URLSchemes = {
            ws:
            {
                getInitial: function(c, d)
                {
                    return a("ws", d, b(c, "flash=false"))
                }
            },
            flash:
            {
                getInitial: function(c, d)
                {
                    return a("ws", d, b(c, "flash=true"))
                }
            },
            sockjs:
            {
                getInitial: function(b, c)
                {
                    return a("http", c, c.httpPath || "/pusher", "")
                },
                getPath: function(a, c)
                {
                    return b(a)
                }
            },
            http:
            {
                getInitial: function(c, d)
                {
                    var e = (d.httpPath || "/pusher") + b(c);
                    return a("http", d, e)
                }
            }
        }
    }.call(this),
    function()
    {
        function a(a, b, c, d, e)
        {
            Pusher.EventsDispatcher.call(this), this.hooks = a, this.name = b, this.priority = c, this.key = d, this.options = e, this.state = "new", this.timeline = e.timeline, this.activityTimeout = e.activityTimeout, this.id = this.timeline.generateUniqueID()
        }
        var b = a.prototype;
        Pusher.Util.extend(b, Pusher.EventsDispatcher.prototype), b.handlesActivityChecks = function()
        {
            return Boolean(this.hooks.handlesActivityChecks)
        }, b.supportsPing = function()
        {
            return Boolean(this.hooks.supportsPing)
        }, b.initialize = function()
        {
            var a = this;
            a.timeline.info(a.buildTimelineMessage(
            {
                transport: a.name + (a.options.encrypted ? "s" : "")
            })), a.hooks.beforeInitialize && a.hooks.beforeInitialize.call(a), a.hooks.isInitialized() ? a.changeState("initialized") : a.hooks.file ? (a.changeState("initializing"), Pusher.Dependencies.load(a.hooks.file,
            {
                encrypted: a.options.encrypted
            }, function(b, c)
            {
                a.hooks.isInitialized() ? (a.changeState("initialized"), c(!0)) : (b && a.onError(b), a.onClose(), c(!1))
            })) : a.onClose()
        }, b.connect = function()
        {
            var a = this;
            if (a.socket || "initialized" !== a.state) return !1;
            var b = a.hooks.urls.getInitial(a.key, a.options);
            try
            {
                a.socket = a.hooks.getSocket(b, a.options)
            }
            catch (c)
            {
                return Pusher.Util.defer(function()
                {
                    a.onError(c), a.changeState("closed")
                }), !1
            }
            return a.bindListeners(), Pusher.debug("Connecting",
            {
                transport: a.name,
                url: b
            }), a.changeState("connecting"), !0
        }, b.close = function()
        {
            return this.socket ? (this.socket.close(), !0) : !1
        }, b.send = function(a)
        {
            var b = this;
            return "open" === b.state ? (Pusher.Util.defer(function()
            {
                b.socket && b.socket.send(a)
            }), !0) : !1
        }, b.ping = function()
        {
            "open" === this.state && this.supportsPing() && this.socket.ping()
        }, b.onOpen = function()
        {
            this.hooks.beforeOpen && this.hooks.beforeOpen(this.socket, this.hooks.urls.getPath(this.key, this.options)), this.changeState("open"), this.socket.onopen = void 0
        }, b.onError = function(a)
        {
            this.emit("error",
            {
                type: "WebSocketError",
                error: a
            }), this.timeline.error(this.buildTimelineMessage(
            {
                error: a.toString()
            }))
        }, b.onClose = function(a)
        {
            a ? this.changeState("closed",
            {
                code: a.code,
                reason: a.reason,
                wasClean: a.wasClean
            }) : this.changeState("closed"), this.unbindListeners(), this.socket = void 0
        }, b.onMessage = function(a)
        {
            this.emit("message", a)
        }, b.onActivity = function()
        {
            this.emit("activity")
        }, b.bindListeners = function()
        {
            var a = this;
            a.socket.onopen = function()
            {
                a.onOpen()
            }, a.socket.onerror = function(b)
            {
                a.onError(b)
            }, a.socket.onclose = function(b)
            {
                a.onClose(b)
            }, a.socket.onmessage = function(b)
            {
                a.onMessage(b)
            }, a.supportsPing() && (a.socket.onactivity = function()
            {
                a.onActivity()
            })
        }, b.unbindListeners = function()
        {
            this.socket && (this.socket.onopen = void 0, this.socket.onerror = void 0, this.socket.onclose = void 0, this.socket.onmessage = void 0, this.supportsPing() && (this.socket.onactivity = void 0))
        }, b.changeState = function(a, b)
        {
            this.state = a, this.timeline.info(this.buildTimelineMessage(
            {
                state: a,
                params: b
            })), this.emit(a, b)
        }, b.buildTimelineMessage = function(a)
        {
            return Pusher.Util.extend(
            {
                cid: this.id
            }, a)
        }, Pusher.TransportConnection = a
    }.call(this),
    function()
    {
        function a(a)
        {
            this.hooks = a
        }
        var b = a.prototype;
        b.isSupported = function(a)
        {
            return this.hooks.isSupported(a)
        }, b.createConnection = function(a, b, c, d)
        {
            return new Pusher.TransportConnection(this.hooks, a, b, c, d)
        }, Pusher.Transport = a
    }.call(this),
    function()
    {
        Pusher.WSTransport = new Pusher.Transport(
        {
            urls: Pusher.URLSchemes.ws,
            handlesActivityChecks: !1,
            supportsPing: !1,
            isInitialized: function()
            {
                return Boolean(window.WebSocket || window.MozWebSocket)
            },
            isSupported: function()
            {
                return Boolean(window.WebSocket || window.MozWebSocket)
            },
            getSocket: function(a)
            {
                return new(window.WebSocket || window.MozWebSocket)(a)
            }
        }), Pusher.FlashTransport = new Pusher.Transport(
        {
            file: "flashfallback",
            urls: Pusher.URLSchemes.flash,
            handlesActivityChecks: !1,
            supportsPing: !1,
            isSupported: function()
            {
                try
                {
                    return Boolean(new ActiveXObject("ShockwaveFlash.ShockwaveFlash"))
                }
                catch (a)
                {
                    try
                    {
                        var b = Pusher.Util.getNavigator();
                        return Boolean(b && b.mimeTypes && void 0 !== b.mimeTypes["application/x-shockwave-flash"])
                    }
                    catch (c)
                    {
                        return !1
                    }
                }
            },
            beforeInitialize: function()
            {
                void 0 === window.WEB_SOCKET_SUPPRESS_CROSS_DOMAIN_SWF_ERROR && (window.WEB_SOCKET_SUPPRESS_CROSS_DOMAIN_SWF_ERROR = !0), window.WEB_SOCKET_SWF_LOCATION = Pusher.Dependencies.getRoot(
                {
                    encrypted: this.options.encrypted
                }) + "/WebSocketMain.swf"
            },
            isInitialized: function()
            {
                return void 0 !== window.FlashWebSocket
            },
            getSocket: function(a)
            {
                return new FlashWebSocket(a)
            }
        }), Pusher.SockJSTransport = new Pusher.Transport(
        {
            file: "sockjs",
            urls: Pusher.URLSchemes.sockjs,
            handlesActivityChecks: !0,
            supportsPing: !1,
            isSupported: function()
            {
                return !0
            },
            isInitialized: function()
            {
                return void 0 !== window.SockJS
            },
            getSocket: function(a, b)
            {
                return new SockJS(a, null,
                {
                    js_path: Pusher.Dependencies.getPath("sockjs",
                    {
                        encrypted: b.encrypted
                    }),
                    ignore_null_origin: b.ignoreNullOrigin
                })
            },
            beforeOpen: function(a, b)
            {
                a.send(JSON.stringify(
                {
                    path: b
                }))
            }
        });
        var a = {
                urls: Pusher.URLSchemes.http,
                handlesActivityChecks: !1,
                supportsPing: !0,
                isInitialized: function()
                {
                    return Boolean(Pusher.HTTP.Socket)
                }
            },
            b = Pusher.Util.extend(
            {
                getSocket: function(a)
                {
                    return Pusher.HTTP.getStreamingSocket(a)
                }
            }, a),
            a = Pusher.Util.extend(
            {
                getSocket: function(a)
                {
                    return Pusher.HTTP.getPollingSocket(a)
                }
            }, a),
            c = {
                file: "xhr",
                isSupported: Pusher.Util.isXHRSupported
            },
            d = {
                file: "xdr",
                isSupported: function(a)
                {
                    return Pusher.Util.isXDRSupported(a.encrypted)
                }
            };
        Pusher.XHRStreamingTransport = new Pusher.Transport(Pusher.Util.extend(
        {}, b, c)), Pusher.XDRStreamingTransport = new Pusher.Transport(Pusher.Util.extend(
        {}, b, d)), Pusher.XHRPollingTransport = new Pusher.Transport(Pusher.Util.extend(
        {}, a, c)), Pusher.XDRPollingTransport = new Pusher.Transport(Pusher.Util.extend(
        {}, a, d))
    }.call(this),
    function()
    {
        function a(a, b, c)
        {
            this.manager = a, this.transport = b, this.minPingDelay = c.minPingDelay, this.maxPingDelay = c.maxPingDelay, this.pingDelay = void 0
        }
        var b = a.prototype;
        b.createConnection = function(a, b, c, d)
        {
            var e = this;
            d = Pusher.Util.extend(
            {}, d,
            {
                activityTimeout: e.pingDelay
            });
            var f = e.transport.createConnection(a, b, c, d),
                g = null,
                h = function()
                {
                    f.unbind("open", h), f.bind("closed", i), g = Pusher.Util.now()
                },
                i = function(a)
                {
                    f.unbind("closed", i), 1002 === a.code || 1003 === a.code ? e.manager.reportDeath() : !a.wasClean && g && (a = Pusher.Util.now() - g, a < 2 * e.maxPingDelay && (e.manager.reportDeath(), e.pingDelay = Math.max(a / 2, e.minPingDelay)))
                };
            return f.bind("open", h), f
        }, b.isSupported = function(a)
        {
            return this.manager.isAlive() && this.transport.isSupported(a)
        }, Pusher.AssistantToTheTransportManager = a
    }.call(this),
    function()
    {
        function a(a)
        {
            this.options = a ||
            {}, this.livesLeft = this.options.lives || 1 / 0
        }
        var b = a.prototype;
        b.getAssistant = function(a)
        {
            return new Pusher.AssistantToTheTransportManager(this, a,
            {
                minPingDelay: this.options.minPingDelay,
                maxPingDelay: this.options.maxPingDelay
            })
        }, b.isAlive = function()
        {
            return 0 < this.livesLeft
        }, b.reportDeath = function()
        {
            this.livesLeft -= 1
        }, Pusher.TransportManager = a
    }.call(this),
    function()
    {
        function a(a)
        {
            return function(b)
            {
                return [a.apply(this, arguments), b]
            }
        }

        function b(a, c)
        {
            if (0 === a.length) return [
                [], c
            ];
            var e = d(a[0], c),
                f = b(a.slice(1), e[1]);
            return [
                [e[0]].concat(f[0]), f[1]
            ]
        }

        function c(a, c)
        {
            if ("string" == typeof a[0] && ":" === a[0].charAt(0))
            {
                var e = c[a[0].slice(1)];
                if (1 < a.length)
                {
                    if ("function" != typeof e) throw "Calling non-function " + a[0];
                    var f = [Pusher.Util.extend(
                    {}, c)].concat(Pusher.Util.map(a.slice(1), function(a)
                    {
                        return d(a, Pusher.Util.extend(
                        {}, c))[0]
                    }));
                    return e.apply(this, f)
                }
                return [e, c]
            }
            return b(a, c)
        }

        function d(a, b)
        {
            if ("string" == typeof a)
            {
                var d;
                if ("string" == typeof a && ":" === a.charAt(0))
                {
                    if (d = b[a.slice(1)], void 0 === d) throw "Undefined symbol " + a;
                    d = [d, b]
                }
                else d = [a, b];
                return d
            }
            return "object" == typeof a && a instanceof Array && 0 < a.length ? c(a, b) : [a, b]
        }
        var e = {
                ws: Pusher.WSTransport,
                flash: Pusher.FlashTransport,
                sockjs: Pusher.SockJSTransport,
                xhr_streaming: Pusher.XHRStreamingTransport,
                xdr_streaming: Pusher.XDRStreamingTransport,
                xhr_polling: Pusher.XHRPollingTransport,
                xdr_polling: Pusher.XDRPollingTransport
            },
            f = {
                isSupported: function()
                {
                    return !1
                },
                connect: function(a, b)
                {
                    var c = Pusher.Util.defer(function()
                    {
                        b(new Pusher.Errors.UnsupportedStrategy)
                    });
                    return {
                        abort: function()
                        {
                            c.ensureAborted()
                        },
                        forceMinPriority: function() {}
                    }
                }
            },
            g = {
                extend: function(a, b, c)
                {
                    return [Pusher.Util.extend(
                    {}, b, c), a]
                },
                def: function(a, b, c)
                {
                    if (void 0 !== a[b]) throw "Redefining symbol " + b;
                    return a[b] = c, [void 0, a]
                },
                def_transport: function(a, b, c, d, g, h)
                {
                    var i = e[c];
                    if (!i) throw new Pusher.Errors.UnsupportedTransport(c);
                    return c = a.enabledTransports && -1 === Pusher.Util.arrayIndexOf(a.enabledTransports, b) || a.disabledTransports && -1 !== Pusher.Util.arrayIndexOf(a.disabledTransports, b) || "flash" === b && !0 === a.disableFlash ? f : new Pusher.TransportStrategy(b, d, h ? h.getAssistant(i) : i, Pusher.Util.extend(
                    {
                        key: a.key,
                        encrypted: a.encrypted,
                        timeline: a.timeline,
                        ignoreNullOrigin: a.ignoreNullOrigin
                    }, g)), d = a.def(a, b, c)[1], d.transports = a.transports ||
                    {}, d.transports[b] = c, [void 0, d]
                },
                transport_manager: a(function(a, b)
                {
                    return new Pusher.TransportManager(b);
                }),
                sequential: a(function(a, b)
                {
                    var c = Array.prototype.slice.call(arguments, 2);
                    return new Pusher.SequentialStrategy(c, b)
                }),
                cached: a(function(a, b, c)
                {
                    return new Pusher.CachedStrategy(c, a.transports,
                    {
                        ttl: b,
                        timeline: a.timeline,
                        encrypted: a.encrypted
                    })
                }),
                first_connected: a(function(a, b)
                {
                    return new Pusher.FirstConnectedStrategy(b)
                }),
                best_connected_ever: a(function()
                {
                    var a = Array.prototype.slice.call(arguments, 1);
                    return new Pusher.BestConnectedEverStrategy(a)
                }),
                delayed: a(function(a, b, c)
                {
                    return new Pusher.DelayedStrategy(c,
                    {
                        delay: b
                    })
                }),
                "if": a(function(a, b, c, d)
                {
                    return new Pusher.IfStrategy(b, c, d)
                }),
                is_supported: a(function(a, b)
                {
                    return function()
                    {
                        return b.isSupported()
                    }
                })
            };
        Pusher.StrategyBuilder = {
            build: function(a, b)
            {
                var c = Pusher.Util.extend(
                {}, g, b);
                return d(a, c)[1].strategy
            }
        }
    }.call(this),
    function()
    {
        Pusher.Protocol = {
            decodeMessage: function(a)
            {
                try
                {
                    var b = JSON.parse(a.data);
                    if ("string" == typeof b.data) try
                    {
                        b.data = JSON.parse(b.data)
                    }
                    catch (c)
                    {
                        if (!(c instanceof SyntaxError)) throw c
                    }
                    return b
                }
                catch (d)
                {
                    throw {
                        type: "MessageParseError",
                        error: d,
                        data: a.data
                    }
                }
            },
            encodeMessage: function(a)
            {
                return JSON.stringify(a)
            },
            processHandshake: function(a)
            {
                if (a = this.decodeMessage(a), "pusher:connection_established" === a.event)
                {
                    if (!a.data.activity_timeout) throw "No activity timeout specified in handshake";
                    return {
                        action: "connected",
                        id: a.data.socket_id,
                        activityTimeout: 1e3 * a.data.activity_timeout
                    }
                }
                if ("pusher:error" === a.event) return {
                    action: this.getCloseAction(a.data),
                    error: this.getCloseError(a.data)
                };
                throw "Invalid handshake"
            },
            getCloseAction: function(a)
            {
                return 4e3 > a.code ? 1002 <= a.code && 1004 >= a.code ? "backoff" : null : 4e3 === a.code ? "ssl_only" : 4100 > a.code ? "refused" : 4200 > a.code ? "backoff" : 4300 > a.code ? "retry" : "refused"
            },
            getCloseError: function(a)
            {
                return 1e3 !== a.code && 1001 !== a.code ?
                {
                    type: "PusherError",
                    data:
                    {
                        code: a.code,
                        message: a.reason || a.message
                    }
                } : null
            }
        }
    }.call(this),
    function()
    {
        function a(a, b)
        {
            Pusher.EventsDispatcher.call(this), this.id = a, this.transport = b, this.activityTimeout = b.activityTimeout, this.bindListeners()
        }
        var b = a.prototype;
        Pusher.Util.extend(b, Pusher.EventsDispatcher.prototype), b.handlesActivityChecks = function()
        {
            return this.transport.handlesActivityChecks()
        }, b.send = function(a)
        {
            return this.transport.send(a)
        }, b.send_event = function(a, b, c)
        {
            return a = {
                event: a,
                data: b
            }, c && (a.channel = c), Pusher.debug("Event sent", a), this.send(Pusher.Protocol.encodeMessage(a))
        }, b.ping = function()
        {
            this.transport.supportsPing() ? this.transport.ping() : this.send_event("pusher:ping",
            {})
        }, b.close = function()
        {
            this.transport.close()
        }, b.bindListeners = function()
        {
            var a = this,
                b = {
                    message: function(b)
                    {
                        var c;
                        try
                        {
                            c = Pusher.Protocol.decodeMessage(b)
                        }
                        catch (d)
                        {
                            a.emit("error",
                            {
                                type: "MessageParseError",
                                error: d,
                                data: b.data
                            })
                        }
                        if (void 0 !== c)
                        {
                            switch (Pusher.debug("Event recd", c), c.event)
                            {
                                case "pusher:error":
                                    a.emit("error",
                                    {
                                        type: "PusherError",
                                        data: c.data
                                    });
                                    break;
                                case "pusher:ping":
                                    a.emit("ping");
                                    break;
                                case "pusher:pong":
                                    a.emit("pong")
                            }
                            a.emit("message", c)
                        }
                    },
                    activity: function()
                    {
                        a.emit("activity")
                    },
                    error: function(b)
                    {
                        a.emit("error",
                        {
                            type: "WebSocketError",
                            error: b
                        })
                    },
                    closed: function(b)
                    {
                        c(), b && b.code && a.handleCloseEvent(b), a.transport = null, a.emit("closed")
                    }
                },
                c = function()
                {
                    Pusher.Util.objectApply(b, function(b, c)
                    {
                        a.transport.unbind(c, b)
                    })
                };
            Pusher.Util.objectApply(b, function(b, c)
            {
                a.transport.bind(c, b)
            })
        }, b.handleCloseEvent = function(a)
        {
            var b = Pusher.Protocol.getCloseAction(a);
            (a = Pusher.Protocol.getCloseError(a)) && this.emit("error", a), b && this.emit(b)
        }, Pusher.Connection = a
    }.call(this),
    function()
    {
        function a(a, b)
        {
            this.transport = a, this.callback = b, this.bindListeners()
        }
        var b = a.prototype;
        b.close = function()
        {
            this.unbindListeners(), this.transport.close()
        }, b.bindListeners = function()
        {
            var a = this;
            a.onMessage = function(b)
            {
                a.unbindListeners();
                try
                {
                    var c = Pusher.Protocol.processHandshake(b);
                    "connected" === c.action ? a.finish("connected",
                    {
                        connection: new Pusher.Connection(c.id, a.transport),
                        activityTimeout: c.activityTimeout
                    }) : (a.finish(c.action,
                    {
                        error: c.error
                    }), a.transport.close())
                }
                catch (d)
                {
                    a.finish("error",
                    {
                        error: d
                    }), a.transport.close()
                }
            }, a.onClosed = function(b)
            {
                a.unbindListeners();
                var c = Pusher.Protocol.getCloseAction(b) || "backoff";
                b = Pusher.Protocol.getCloseError(b), a.finish(c,
                {
                    error: b
                })
            }, a.transport.bind("message", a.onMessage), a.transport.bind("closed", a.onClosed)
        }, b.unbindListeners = function()
        {
            this.transport.unbind("message", this.onMessage), this.transport.unbind("closed", this.onClosed)
        }, b.finish = function(a, b)
        {
            this.callback(Pusher.Util.extend(
            {
                transport: this.transport,
                action: a
            }, b))
        }, Pusher.Handshake = a
    }.call(this),
    function()
    {
        function a(a, b)
        {
            Pusher.EventsDispatcher.call(this), this.key = a, this.options = b ||
            {}, this.state = "initialized", this.connection = null, this.encrypted = !!b.encrypted, this.timeline = this.options.timeline, this.connectionCallbacks = this.buildConnectionCallbacks(), this.errorCallbacks = this.buildErrorCallbacks(), this.handshakeCallbacks = this.buildHandshakeCallbacks(this.errorCallbacks);
            var c = this;
            Pusher.Network.bind("online", function()
            {
                c.timeline.info(
                {
                    netinfo: "online"
                }), ("connecting" === c.state || "unavailable" === c.state) && c.retryIn(0)
            }), Pusher.Network.bind("offline", function()
            {
                c.timeline.info(
                {
                    netinfo: "offline"
                }), c.connection && c.sendActivityCheck()
            }), this.updateStrategy()
        }
        var b = a.prototype;
        Pusher.Util.extend(b, Pusher.EventsDispatcher.prototype), b.connect = function()
        {
            !this.connection && !this.runner && (this.strategy.isSupported() ? (this.updateState("connecting"), this.startConnecting(), this.setUnavailableTimer()) : this.updateState("failed"))
        }, b.send = function(a)
        {
            return this.connection ? this.connection.send(a) : !1
        }, b.send_event = function(a, b, c)
        {
            return this.connection ? this.connection.send_event(a, b, c) : !1
        }, b.disconnect = function()
        {
            this.disconnectInternally(), this.updateState("disconnected")
        }, b.isEncrypted = function()
        {
            return this.encrypted
        }, b.startConnecting = function()
        {
            var a = this,
                b = function(c, d)
                {
                    c ? a.runner = a.strategy.connect(0, b) : "error" === d.action ? (a.emit("error",
                    {
                        type: "HandshakeError",
                        error: d.error
                    }), a.timeline.error(
                    {
                        handshakeError: d.error
                    })) : (a.abortConnecting(), a.handshakeCallbacks[d.action](d))
                };
            a.runner = a.strategy.connect(0, b)
        }, b.abortConnecting = function()
        {
            this.runner && (this.runner.abort(), this.runner = null)
        }, b.disconnectInternally = function()
        {
            this.abortConnecting(), this.clearRetryTimer(), this.clearUnavailableTimer(), this.connection && this.abandonConnection().close()
        }, b.updateStrategy = function()
        {
            this.strategy = this.options.getStrategy(
            {
                key: this.key,
                timeline: this.timeline,
                encrypted: this.encrypted
            })
        }, b.retryIn = function(a)
        {
            var b = this;
            b.timeline.info(
            {
                action: "retry",
                delay: a
            }), a > 0 && b.emit("connecting_in", Math.round(a / 1e3)), b.retryTimer = new Pusher.Timer(a || 0, function()
            {
                b.disconnectInternally(), b.connect()
            })
        }, b.clearRetryTimer = function()
        {
            this.retryTimer && (this.retryTimer.ensureAborted(), this.retryTimer = null)
        }, b.setUnavailableTimer = function()
        {
            var a = this;
            a.unavailableTimer = new Pusher.Timer(a.options.unavailableTimeout, function()
            {
                a.updateState("unavailable")
            })
        }, b.clearUnavailableTimer = function()
        {
            this.unavailableTimer && this.unavailableTimer.ensureAborted()
        }, b.sendActivityCheck = function()
        {
            var a = this;
            a.stopActivityCheck(), a.connection.ping(), a.activityTimer = new Pusher.Timer(a.options.pongTimeout, function()
            {
                a.timeline.error(
                {
                    pong_timed_out: a.options.pongTimeout
                }), a.retryIn(0)
            })
        }, b.resetActivityCheck = function()
        {
            var a = this;
            a.stopActivityCheck(), a.connection.handlesActivityChecks() || (a.activityTimer = new Pusher.Timer(a.activityTimeout, function()
            {
                a.sendActivityCheck()
            }))
        }, b.stopActivityCheck = function()
        {
            this.activityTimer && this.activityTimer.ensureAborted()
        }, b.buildConnectionCallbacks = function()
        {
            var a = this;
            return {
                message: function(b)
                {
                    a.resetActivityCheck(), a.emit("message", b)
                },
                ping: function()
                {
                    a.send_event("pusher:pong",
                    {})
                },
                activity: function()
                {
                    a.resetActivityCheck()
                },
                error: function(b)
                {
                    a.emit("error",
                    {
                        type: "WebSocketError",
                        error: b
                    })
                },
                closed: function()
                {
                    a.abandonConnection(), a.shouldRetry() && a.retryIn(1e3)
                }
            }
        }, b.buildHandshakeCallbacks = function(a)
        {
            var b = this;
            return Pusher.Util.extend(
            {}, a,
            {
                connected: function(a)
                {
                    b.activityTimeout = Math.min(b.options.activityTimeout, a.activityTimeout, a.connection.activityTimeout || 1 / 0), b.clearUnavailableTimer(), b.setConnection(a.connection), b.socket_id = b.connection.id, b.updateState("connected",
                    {
                        socket_id: b.socket_id
                    })
                }
            })
        }, b.buildErrorCallbacks = function()
        {
            function a(a)
            {
                return function(c)
                {
                    c.error && b.emit("error",
                    {
                        type: "WebSocketError",
                        error: c.error
                    }), a(c)
                }
            }
            var b = this;
            return {
                ssl_only: a(function()
                {
                    b.encrypted = !0, b.updateStrategy(), b.retryIn(0)
                }),
                refused: a(function()
                {
                    b.disconnect()
                }),
                backoff: a(function()
                {
                    b.retryIn(1e3)
                }),
                retry: a(function()
                {
                    b.retryIn(0)
                })
            }
        }, b.setConnection = function(a)
        {
            this.connection = a;
            for (var b in this.connectionCallbacks) this.connection.bind(b, this.connectionCallbacks[b]);
            this.resetActivityCheck()
        }, b.abandonConnection = function()
        {
            if (this.connection)
            {
                this.stopActivityCheck();
                for (var a in this.connectionCallbacks) this.connection.unbind(a, this.connectionCallbacks[a]);
                return a = this.connection, this.connection = null, a
            }
        }, b.updateState = function(a, b)
        {
            var c = this.state;
            this.state = a, c !== a && (Pusher.debug("State changed", c + " -> " + a), this.timeline.info(
            {
                state: a,
                params: b
            }), this.emit("state_change",
            {
                previous: c,
                current: a
            }), this.emit(a, b))
        }, b.shouldRetry = function()
        {
            return "connecting" === this.state || "connected" === this.state
        }, Pusher.ConnectionManager = a
    }.call(this),
    function()
    {
        function a()
        {
            Pusher.EventsDispatcher.call(this);
            var a = this;
            void 0 !== window.addEventListener && (window.addEventListener("online", function()
            {
                a.emit("online")
            }, !1), window.addEventListener("offline", function()
            {
                a.emit("offline")
            }, !1))
        }
        Pusher.Util.extend(a.prototype, Pusher.EventsDispatcher.prototype), a.prototype.isOnline = function()
        {
            return void 0 === window.navigator.onLine ? !0 : window.navigator.onLine
        }, Pusher.NetInfo = a, Pusher.Network = new a
    }.call(this),
    function()
    {
        function a()
        {
            this.reset()
        }
        var b = a.prototype;
        b.get = function(a)
        {
            return Object.prototype.hasOwnProperty.call(this.members, a) ?
            {
                id: a,
                info: this.members[a]
            } : null
        }, b.each = function(a)
        {
            var b = this;
            Pusher.Util.objectApply(b.members, function(c, d)
            {
                a(b.get(d))
            })
        }, b.setMyID = function(a)
        {
            this.myID = a
        }, b.onSubscription = function(a)
        {
            this.members = a.presence.hash, this.count = a.presence.count, this.me = this.get(this.myID)
        }, b.addMember = function(a)
        {
            return null === this.get(a.user_id) && this.count++, this.members[a.user_id] = a.user_info, this.get(a.user_id)
        }, b.removeMember = function(a)
        {
            var b = this.get(a.user_id);
            return b && (delete this.members[a.user_id], this.count--), b
        }, b.reset = function()
        {
            this.members = {}, this.count = 0, this.me = this.myID = null
        }, Pusher.Members = a
    }.call(this),
    function()
    {
        function a(a, b)
        {
            Pusher.EventsDispatcher.call(this, function(b, c)
            {
                Pusher.debug("No callbacks on " + a + " for " + b)
            }), this.name = a, this.pusher = b, this.subscribed = !1
        }
        var b = a.prototype;
        Pusher.Util.extend(b, Pusher.EventsDispatcher.prototype), b.authorize = function(a, b)
        {
            return b(!1,
            {})
        }, b.trigger = function(a, b)
        {
            if (0 !== a.indexOf("client-")) throw new Pusher.Errors.BadEventName("Event '" + a + "' does not start with 'client-'");
            return this.pusher.send_event(a, b, this.name)
        }, b.disconnect = function()
        {
            this.subscribed = !1
        }, b.handleEvent = function(a, b)
        {
            0 === a.indexOf("pusher_internal:") ? "pusher_internal:subscription_succeeded" === a && (this.subscribed = !0, this.emit("pusher:subscription_succeeded", b)) : this.emit(a, b)
        }, b.subscribe = function()
        {
            var a = this;
            a.authorize(a.pusher.connection.socket_id, function(b, c)
            {
                b ? a.handleEvent("pusher:subscription_error", c) : a.pusher.send_event("pusher:subscribe",
                {
                    auth: c.auth,
                    channel_data: c.channel_data,
                    channel: a.name
                })
            })
        }, b.unsubscribe = function()
        {
            this.pusher.send_event("pusher:unsubscribe",
            {
                channel: this.name
            })
        }, Pusher.Channel = a
    }.call(this),
    function()
    {
        function a(a, b)
        {
            Pusher.Channel.call(this, a, b)
        }
        var b = a.prototype;
        Pusher.Util.extend(b, Pusher.Channel.prototype), b.authorize = function(a, b)
        {
            return new Pusher.Channel.Authorizer(this, this.pusher.config).authorize(a, b)
        }, Pusher.PrivateChannel = a
    }.call(this),
    function()
    {
        function a(a, b)
        {
            Pusher.PrivateChannel.call(this, a, b), this.members = new Pusher.Members
        }
        var b = a.prototype;
        Pusher.Util.extend(b, Pusher.PrivateChannel.prototype), b.authorize = function(a, b)
        {
            var c = this;
            Pusher.PrivateChannel.prototype.authorize.call(c, a, function(a, d)
            {
                if (!a)
                {
                    if (void 0 === d.channel_data) return Pusher.warn("Invalid auth response for channel '" + c.name + "', expected 'channel_data' field"), void b("Invalid auth response");
                    var e = JSON.parse(d.channel_data);
                    c.members.setMyID(e.user_id)
                }
                b(a, d)
            })
        }, b.handleEvent = function(a, b)
        {
            switch (a)
            {
                case "pusher_internal:subscription_succeeded":
                    this.members.onSubscription(b), this.subscribed = !0, this.emit("pusher:subscription_succeeded", this.members);
                    break;
                case "pusher_internal:member_added":
                    var c = this.members.addMember(b);
                    this.emit("pusher:member_added", c);
                    break;
                case "pusher_internal:member_removed":
                    (c = this.members.removeMember(b)) && this.emit("pusher:member_removed", c);
                    break;
                default:
                    Pusher.PrivateChannel.prototype.handleEvent.call(this, a, b)
            }
        }, b.disconnect = function()
        {
            this.members.reset(), Pusher.PrivateChannel.prototype.disconnect.call(this)
        }, Pusher.PresenceChannel = a
    }.call(this),
    function()
    {
        function a()
        {
            this.channels = {}
        }
        var b = a.prototype;
        b.add = function(a, b)
        {
            if (!this.channels[a])
            {
                var d, c = this.channels;
                d = 0 === a.indexOf("private-") ? new Pusher.PrivateChannel(a, b) : 0 === a.indexOf("presence-") ? new Pusher.PresenceChannel(a, b) : new Pusher.Channel(a, b), c[a] = d
            }
            return this.channels[a]
        }, b.all = function(a)
        {
            return Pusher.Util.values(this.channels)
        }, b.find = function(a)
        {
            return this.channels[a]
        }, b.remove = function(a)
        {
            var b = this.channels[a];
            return delete this.channels[a], b
        }, b.disconnect = function()
        {
            Pusher.Util.objectApply(this.channels, function(a)
            {
                a.disconnect()
            })
        }, Pusher.Channels = a
    }.call(this),
    function()
    {
        Pusher.Channel.Authorizer = function(a, b)
        {
            this.channel = a, this.type = b.authTransport, this.options = b, this.authOptions = (b ||
            {}).auth ||
            {}
        }, Pusher.Channel.Authorizer.prototype = {
            composeQuery: function(a)
            {
                a = "socket_id=" + encodeURIComponent(a) + "&channel_name=" + encodeURIComponent(this.channel.name);
                for (var b in this.authOptions.params) a += "&" + encodeURIComponent(b) + "=" + encodeURIComponent(this.authOptions.params[b]);
                return a
            },
            authorize: function(a, b)
            {
                return Pusher.authorizers[this.type].call(this, a, b)
            }
        };
        var a = 1;
        Pusher.auth_callbacks = {}, Pusher.authorizers = {
            ajax: function(a, b)
            {
                var c;
                c = Pusher.XHR ? new Pusher.XHR : window.XMLHttpRequest ? new window.XMLHttpRequest : new ActiveXObject("Microsoft.XMLHTTP"), c.open("POST", this.options.authEndpoint, !0), c.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
                for (var d in this.authOptions.headers) c.setRequestHeader(d, this.authOptions.headers[d]);
                return c.onreadystatechange = function()
                {
                    if (4 === c.readyState)
                        if (200 === c.status)
                        {
                            var a, d = !1;
                            try
                            {
                                a = JSON.parse(c.responseText), d = !0
                            }
                            catch (e)
                            {
                                b(!0, "JSON returned from webapp was invalid, yet status code was 200. Data was: " + c.responseText)
                            }
                            d && b(!1, a)
                        }
                        else Pusher.warn("Couldn't get auth info from your webapp", c.status), b(!0, c.status)
                }, c.send(this.composeQuery(a)), c
            },
            jsonp: function(b, c)
            {
                void 0 !== this.authOptions.headers && Pusher.warn("Warn", "To send headers with the auth request, you must use AJAX, rather than JSONP.");
                var d = a.toString();
                a++;
                var e = Pusher.Util.getDocument(),
                    f = e.createElement("script");
                Pusher.auth_callbacks[d] = function(a)
                {
                    c(!1, a)
                }, f.src = this.options.authEndpoint + "?callback=" + encodeURIComponent("Pusher.auth_callbacks['" + d + "']") + "&" + this.composeQuery(b), d = e.getElementsByTagName("head")[0] || e.documentElement, d.insertBefore(f, d.firstChild)
            }
        }
    }.call(this);
